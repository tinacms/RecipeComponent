(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("fetch-ponyfill")) : typeof define === "function" && define.amd ? define(["exports", "fetch-ponyfill"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.tinacms = {}, global.NOOP));
})(this, function(exports2, fetchPonyfill) {
  "use strict";
  const { fetch: fetchPonyfillFN, Headers: HeadersPonyfill } = fetchPonyfill();
  const fetchDefined = typeof fetch === "undefined" ? fetchPonyfillFN : fetch;
  const HeadersDefined = typeof Headers === "undefined" ? HeadersPonyfill : Headers;
  const TINA_HOST = "content.tinajs.io";
  class TinaClient {
    constructor({
      token,
      url,
      queries,
      errorPolicy,
      cacheDir
    }) {
      this.initialized = false;
      this.apiUrl = url;
      this.readonlyToken = token == null ? void 0 : token.trim();
      this.queries = queries(this);
      this.errorPolicy = errorPolicy || "throw";
      this.cacheDir = cacheDir || "";
    }
    async init() {
      if (this.initialized) {
        return;
      }
      try {
        if (this.cacheDir && typeof window === "undefined" && typeof require !== "undefined") {
          const { NodeCache: NodeCache2 } = await Promise.resolve().then(() => nodeCache);
          this.cache = await NodeCache2(this.cacheDir);
        }
      } catch (e) {
        console.error(e);
      }
      this.initialized = true;
    }
    async request({ errorPolicy, ...args }, options) {
      var _a;
      await this.init();
      const errorPolicyDefined = errorPolicy || this.errorPolicy;
      const headers = new HeadersDefined();
      if (this.readonlyToken) {
        headers.append("X-API-KEY", this.readonlyToken);
      }
      headers.append("Content-Type", "application/json");
      if (options == null ? void 0 : options.fetchOptions) {
        if ((_a = options == null ? void 0 : options.fetchOptions) == null ? void 0 : _a.headers) {
          Object.entries(options.fetchOptions.headers).forEach(([key2, value]) => {
            headers.append(key2, value);
          });
        }
      }
      const { headers: _, ...providedFetchOptions } = (options == null ? void 0 : options.fetchOptions) || {};
      const bodyString = JSON.stringify({
        query: args.query,
        variables: (args == null ? void 0 : args.variables) || {}
      });
      const url = (args == null ? void 0 : args.url) || this.apiUrl;
      const optionsObject = {
        method: "POST",
        headers,
        body: bodyString,
        redirect: "follow",
        ...providedFetchOptions
      };
      let key = "";
      if (this.cache) {
        key = this.cache.makeKey(bodyString);
        const value = await this.cache.get(key);
        if (value) {
          return value;
        }
      }
      const res = await fetchDefined(url, optionsObject);
      if (!res.ok) {
        let additionalInfo = "";
        if (res.status === 401) {
          additionalInfo = "Please check that your client ID, URL and read only token are configured properly.";
        }
        throw new Error(
          `Server responded with status code ${res.status}, ${res.statusText}. ${additionalInfo ? additionalInfo : ""} Please see our FAQ for more information: https://tina.io/docs/errors/faq/`
        );
      }
      const json = await res.json();
      if (json.errors && errorPolicyDefined === "throw") {
        throw new Error(
          `Unable to fetch, please see our FAQ for more information: https://tina.io/docs/errors/faq/
        Errors: 
	${json.errors.map((error) => error.message).join("\n")}`
        );
      }
      const result = {
        data: json == null ? void 0 : json.data,
        errors: (json == null ? void 0 : json.errors) || null,
        query: args.query
      };
      if (this.cache) {
        await this.cache.set(key, result);
      }
      return result;
    }
  }
  function createClient(args) {
    const client = new TinaClient(args);
    return client;
  }
  const makeCacheDir = async (dir, fs, path, os) => {
    const pathParts = dir.split(path.sep).filter(Boolean);
    const cacheHash = pathParts[pathParts.length - 1];
    const rootUser = pathParts[0];
    let cacheDir = dir;
    if (!fs.existsSync(path.join(path.sep, rootUser))) {
      cacheDir = path.join(os.tmpdir(), cacheHash);
    }
    try {
      fs.mkdirSync(cacheDir, { recursive: true });
    } catch (error) {
      throw new Error(`Failed to create cache directory: ${error.message}`);
    }
    return cacheDir;
  };
  const NodeCache = async (dir) => {
    const fs = require("node:fs");
    const path = require("node:path");
    const os = require("node:os");
    const { createHash } = require("node:crypto");
    const cacheDir = await makeCacheDir(dir, fs, path, os);
    return {
      makeKey: (key) => {
        const input = key && key instanceof Object ? JSON.stringify(key) : key || "";
        return createHash("sha256").update(input).digest("hex");
      },
      get: async (key) => {
        try {
          const data = await fs.promises.readFile(`${cacheDir}/${key}`, "utf-8");
          return JSON.parse(data);
        } catch (e) {
          if (e.code === "ENOENT") {
            return void 0;
          }
          throw e;
        }
      },
      set: async (key, value) => {
        await fs.promises.writeFile(
          `${cacheDir}/${key}`,
          JSON.stringify(value),
          "utf-8"
        );
      }
    };
  };
  const nodeCache = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    NodeCache,
    makeCacheDir
  }, Symbol.toStringTag, { value: "Module" }));
  exports2.TINA_HOST = TINA_HOST;
  exports2.TinaClient = TinaClient;
  exports2.createClient = createClient;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
